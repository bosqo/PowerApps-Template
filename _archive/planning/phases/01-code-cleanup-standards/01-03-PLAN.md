---
phase: 01-code-cleanup-standards
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/App-OnStart-Minimal.fx
  - src/App-Formulas-Template.fx
autonomous: true

must_haves:
  truths:
    - "AppState structure is logically consistent with no redundant fields"
    - "ActiveFilters structure is optimized for common filter patterns"
    - "UIState structure eliminates redundancy and follows single responsibility"
    - "All variables have documented purpose and schema in comments"
    - "No circular dependencies exist between variables and Named Formulas"
  artifacts:
    - path: "src/App-OnStart-Minimal.fx"
      provides: "Optimized state variable structure with inline schema documentation"
      contains: "// Schema:"
    - path: "src/App-Formulas-Template.fx"
      provides: "Named Formulas with documented dependencies"
      contains: "// Depends on:"
  key_links:
    - from: "AppState"
      to: "Screen navigation and error handling"
      via: "CurrentScreen, ShowErrorDialog fields"
      pattern: "AppState\\.(CurrentScreen|ShowErrorDialog)"
    - from: "ActiveFilters"
      to: "Gallery filtering and UDFs"
      via: "GetUserScope(), GetDepartmentScope() initialize filters"
      pattern: "ActiveFilters\\.(UserScope|DepartmentScope)"
    - from: "UIState"
      to: "Panel and dialog visibility"
      via: "IsDetailsPanelOpen, IsConfirmDialogOpen fields"
      pattern: "UIState\\.(IsDetailsPanelOpen|IsConfirmDialogOpen)"
    - from: "UserProfile Named Formula"
      to: "UserRoles Named Formula"
      via: "UserRoles depends on UserProfile.Email"
      pattern: "UserProfile\\."
    - from: "UserRoles Named Formula"
      to: "UserPermissions Named Formula"
      via: "UserPermissions derives from UserRoles booleans"
      pattern: "UserRoles\\.(IsAdmin|IsManager)"
---

<objective>
Optimize state variable structure (AppState, ActiveFilters, UIState) by eliminating redundancy, documenting schemas, and validating dependency chains.

Purpose: Create clean, maintainable variable structure with clear purpose for each field, documented schemas for developer understanding, and validated dependency flow from Named Formulas to variables.

Output: Optimized App-OnStart-Minimal.fx with documented variable schemas and validated App-Formulas-Template.fx dependency chain.
</objective>

<execution_context>
@D:\_Repo\repos\PowerApps-Vibe-Claude\.claude\workflows\execute-plan.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.claude\templates\summary.md
</execution_context>

<context>
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\PROJECT.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\ROADMAP.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\STATE.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\codebase\ARCHITECTURE.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\phases\01-code-cleanup-standards\01-02-SUMMARY.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\src\App-OnStart-Minimal.fx
@D:\_Repo\repos\PowerApps-Vibe-Claude\src\App-Formulas-Template.fx
</context>

<tasks>

<task type="auto">
  <name>Review and optimize AppState structure</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
    Review AppState variable (lines 33-56) for logical consistency and redundancy.

    Current structure:
    ```powerfx
    Set(AppState, {
        // Loading States
        IsLoading: false,
        IsInitializing: true,
        IsSaving: false,

        // Navigation
        CurrentScreen: "Home",
        PreviousScreen: Blank(),

        // Session Info
        SessionStart: Now(),
        LastRefresh: Now(),
        LastAction: Blank(),

        // Connectivity
        IsOnline: Connection.Connected,

        // Error Handling
        LastError: Blank(),
        ShowErrorDialog: false,
        ErrorMessage: "",
        ErrorDetails: ""
    });
    ```

    ANALYZE for:
    1. **Redundancy:** Are any fields duplicates or derivable from others?
    2. **Consistency:** Do related fields use consistent naming (e.g., Is* prefix for booleans)?
    3. **Completeness:** Are critical app states missing?

    FINDINGS (likely all OK, but verify):
    - IsLoading vs IsInitializing - Both needed (different states)
    - CurrentScreen vs PreviousScreen - Both needed (navigation history)
    - LastError vs ErrorMessage/ErrorDetails - LastError might be redundant if ErrorMessage exists
    - Connection.Connected - Should this be cached or always read fresh?

    OPTIMIZE if needed:
    1. Consolidate LastError into ErrorMessage (LastError seems redundant)
    2. Consider removing IsOnline (read Connection.Connected directly when needed)
    3. Add ShowSuccessMessage field if success notifications need state

    DOCUMENT schema inline:
    ```powerfx
    // ============================================================
    // 1. APPLICATION STATE (Mutable)
    // ============================================================
    // Purpose: Global application state that changes during usage
    //
    // Schema:
    // - IsLoading: Boolean - General loading indicator
    // - IsInitializing: Boolean - App startup loading (first load only)
    // - IsSaving: Boolean - Save operation in progress
    // - CurrentScreen: Text - Active screen name for navigation
    // - PreviousScreen: Text - Previous screen for back navigation
    // - SessionStart: DateTime - App session start time
    // - LastRefresh: DateTime - Last data refresh timestamp
    // - LastAction: Text - Last user action performed (for debugging)
    // - IsOnline: Boolean - Network connectivity status
    // - ShowErrorDialog: Boolean - Error dialog visibility state
    // - ErrorMessage: Text - User-facing error message
    // - ErrorDetails: Text - Technical error details for debugging
    //
    // Usage:
    // - Set(AppState, Patch(AppState, {IsLoading: true})) to update
    // - Read: AppState.IsLoading, AppState.CurrentScreen, etc.
    //
    Set(AppState, {
        ...
    ```
  </action>
  <verify>
    Read lines 29-56 of src/App-OnStart-Minimal.fx.
    Confirm AppState structure includes:
    - Clear field grouping (Loading States, Navigation, Session Info, Connectivity, Error Handling)
    - Consistent boolean naming (Is* prefix)
    - Inline schema documentation explaining each field purpose and usage
    - No obvious redundancy (each field serves distinct purpose)

    Check if optimizations were made:
    - LastError removed if redundant with ErrorMessage
    - IsOnline clarified (cached vs fresh read)
  </verify>
  <done>
    AppState structure is logically consistent with clear field grouping.
    All boolean fields use Is* or Show* prefix consistently.
    Inline schema comment documents each field's purpose, type, and usage.
    No redundant fields remain (each serves distinct purpose).
    Any removed fields documented in SUMMARY with migration notes.
  </done>
</task>

<task type="auto">
  <name>Review and optimize ActiveFilters structure</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
    Review ActiveFilters variable (lines 64-83) for optimization and common filter pattern support.

    Current structure:
    ```powerfx
    Set(ActiveFilters, {
        // Scope Filters (initialized from UDFs)
        UserScope: GetUserScope(),
        DepartmentScope: GetDepartmentScope(),

        // Status Filters
        ActiveOnly: true,
        IncludeArchived: false,
        StatusFilter: Blank(),

        // Search & Custom Filters
        SearchTerm: "",
        CategoryFilter: Blank(),
        PriorityFilter: Blank(),
        OwnerFilter: Blank(),

        // Pagination
        CurrentPage: 1,
        PageSize: AppConfig.ItemsPerPage
    });
    ```

    ANALYZE for:
    1. **Redundancy:** ActiveOnly vs IncludeArchived (inverses of each other?)
    2. **Completeness:** Common filter patterns missing (date range, tags)?
    3. **Delegation:** Will these filters work with delegation-friendly patterns?

    FINDINGS:
    - ActiveOnly=true + IncludeArchived=false is redundant (choose one)
    - Date range filters missing (common requirement: ThisWeek, ThisMonth, Custom)
    - Tag/label filters missing (common multi-select pattern)

    OPTIMIZE:
    1. Choose between ActiveOnly or IncludeArchived (recommend IncludeArchived for clarity)
    2. Add DateRangeFilter: "All" | "Today" | "ThisWeek" | "ThisMonth" | "Custom"
    3. Add CustomDateStart and CustomDateEnd for date range
    4. Consider adding TagFilters if tagging system exists

    DOCUMENT schema inline:
    ```powerfx
    // ============================================================
    // 2. ACTIVE FILTERS (Mutable)
    // ============================================================
    // Purpose: User-modifiable filter state for data views (galleries, lists)
    // Initialized from UDFs and AppConfig, modified via UI controls
    //
    // Schema:
    // - UserScope: Text - User data scope from GetUserScope() ("All", "My", "Department")
    // - DepartmentScope: Text - Department scope from GetDepartmentScope()
    // - IncludeArchived: Boolean - Include archived records in views
    // - StatusFilter: Text - Selected status value (Blank = all statuses)
    // - DateRangeFilter: Text - Date range preset ("All", "Today", "ThisWeek", "ThisMonth", "Custom")
    // - CustomDateStart: Date - Custom date range start (if DateRangeFilter = "Custom")
    // - CustomDateEnd: Date - Custom date range end (if DateRangeFilter = "Custom")
    // - SearchTerm: Text - Text search query across searchable fields
    // - CategoryFilter: Text - Selected category (Blank = all categories)
    // - PriorityFilter: Text - Selected priority (Blank = all priorities)
    // - OwnerFilter: Text - Filter by owner email (Blank = all owners)
    // - CurrentPage: Number - Current page for pagination (1-based)
    // - PageSize: Number - Records per page for pagination
    //
    // Usage:
    // - Set(ActiveFilters, Patch(ActiveFilters, {SearchTerm: "query"})) to update
    // - Reset: Set(ActiveFilters, Patch(ActiveFilters, {SearchTerm: "", StatusFilter: Blank()}))
    // - Gallery Items: Filter(DataSource, ... ActiveFilters.SearchTerm ... ActiveFilters.StatusFilter ...)
    //
    Set(ActiveFilters, {
        ...
    ```
  </action>
  <verify>
    Read lines 59-83 of src/App-OnStart-Minimal.fx.
    Confirm ActiveFilters structure:
    - No redundant inverse boolean pairs (either ActiveOnly or IncludeArchived, not both)
    - Date range filter fields exist (DateRangeFilter, CustomDateStart, CustomDateEnd)
    - Inline schema documentation explains each filter purpose and usage
    - All filter fields initialized to sensible defaults

    Check Control-Patterns-Modern.fx for filter usage:
    - Gallery.Items formulas reference ActiveFilters.* fields
    - No broken references after any field renames/removals
  </verify>
  <done>
    ActiveFilters structure optimized with no redundant inverse pairs.
    Date range filter fields added for common temporal filtering patterns.
    Inline schema comment documents each filter's purpose, type, allowed values, and usage.
    All filter fields have sensible defaults (Blank() for optional, specific values for required).
    Control-Patterns-Modern.fx references updated for any changed filter names.
  </done>
</task>

<task type="auto">
  <name>Review and optimize UIState structure</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
    Review UIState variable (lines 90-111) for redundancy and single responsibility.

    Current structure:
    ```powerfx
    Set(UIState, {
        // Selection State
        SelectedItem: Blank(),
        SelectedItems: Table(),
        SelectionMode: "single",  // "single" | "multiple"

        // Panel States
        IsDetailsPanelOpen: false,
        IsFilterPanelOpen: false,
        IsSettingsPanelOpen: false,

        // Dialog States
        IsConfirmDialogOpen: false,
        ConfirmDialogTitle: "",
        ConfirmDialogMessage: "",
        ConfirmDialogAction: Blank(),

        // Form States
        IsEditMode: false,
        FormMode: FormMode.View,
        UnsavedChanges: false
    });
    ```

    ANALYZE for:
    1. **Redundancy:** IsEditMode vs FormMode (FormMode.Edit implies IsEditMode=true)
    2. **Completeness:** Common UI states missing (loading spinners, toasts)?
    3. **Organization:** Should selection state be separate from UI state?

    FINDINGS:
    - IsEditMode is redundant with FormMode (FormMode = FormMode.Edit means editing)
    - Toast/notification state might belong here (if not using Notify())
    - SelectedItem vs SelectedItems follows single/multiple pattern correctly

    OPTIMIZE:
    1. Remove IsEditMode (use FormMode = FormMode.Edit instead)
    2. Consider adding toast state if implementing custom notifications (Phase 4):
       - ShowToast: Boolean
       - ToastMessage: Text
       - ToastType: "Info" | "Success" | "Warning" | "Error"
    3. Verify panel open states are all needed (sometimes only one panel can be open)

    DOCUMENT schema inline:
    ```powerfx
    // ============================================================
    // 3. UI STATE (Mutable)
    // ============================================================
    // Purpose: UI component state (selections, panels, dialogs, forms)
    // Ephemeral state that doesn't persist between sessions
    //
    // Schema:
    // - SelectedItem: Record - Currently selected single item (Blank if none)
    // - SelectedItems: Table - Selected items in multi-select mode (empty table if none)
    // - SelectionMode: Text - Selection behavior ("single" or "multiple")
    // - IsDetailsPanelOpen: Boolean - Details panel visibility
    // - IsFilterPanelOpen: Boolean - Filter panel visibility
    // - IsSettingsPanelOpen: Boolean - Settings panel visibility
    // - IsConfirmDialogOpen: Boolean - Confirmation dialog visibility
    // - ConfirmDialogTitle: Text - Dialog title text
    // - ConfirmDialogMessage: Text - Dialog message text
    // - ConfirmDialogAction: Record - Action to execute on confirm (function reference)
    // - FormMode: FormMode - Form display mode (FormMode.View, FormMode.Edit, FormMode.New)
    // - UnsavedChanges: Boolean - Form has unsaved modifications
    //
    // Usage:
    // - Set(UIState, Patch(UIState, {SelectedItem: Gallery.Selected})) to update
    // - Panel visibility: Panel.Visible = UIState.IsDetailsPanelOpen
    // - Form mode: Form.Mode = UIState.FormMode
    //
    Set(UIState, {
        ...
    ```
  </action>
  <verify>
    Read lines 86-111 of src/App-OnStart-Minimal.fx.
    Confirm UIState structure:
    - IsEditMode removed (redundant with FormMode)
    - Clear separation of concerns (selection, panels, dialogs, forms)
    - Inline schema documentation explains each field purpose and usage
    - All UI state fields have appropriate defaults (false for booleans, Blank() for optional)

    Check Control-Patterns-Modern.fx for UIState usage:
    - Panel.Visible formulas reference UIState.Is*PanelOpen
    - Form.Mode references UIState.FormMode (not UIState.IsEditMode)
    - No broken references after IsEditMode removal
  </verify>
  <done>
    UIState structure follows single responsibility (each field serves one UI purpose).
    IsEditMode removed (redundant with FormMode enum).
    Inline schema comment documents each field's purpose, type, allowed values, and usage.
    All UI state fields initialized to sensible defaults (closed panels, view mode, no selection).
    Control-Patterns-Modern.fx updated to use FormMode instead of IsEditMode.
  </done>
</task>

<task type="auto">
  <name>Document variable schemas and usage patterns</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
    Add comprehensive documentation for each variable explaining purpose, schema, and usage patterns.

    FOR EACH VARIABLE (AppState, ActiveFilters, UIState):
    1. Header comment with purpose statement
    2. Schema documentation listing all fields with:
       - Field name
       - Type (Boolean, Text, Number, Date, DateTime, Record, Table)
       - Purpose/description
       - Allowed values (for enums like SelectionMode: "single" | "multiple")
    3. Usage examples:
       - How to update: Set(Var, Patch(Var, {Field: Value}))
       - How to read: Var.Field
       - Where used: Gallery.Items, Panel.Visible, etc.

    ALSO ADD at top of file (after line 27):
    ```powerfx
    // ============================================================
    // VARIABLE STRUCTURE PHILOSOPHY
    // ============================================================
    //
    // This template uses THREE STATE VARIABLES (not dozens):
    //
    // 1. AppState - Application-wide state (loading, navigation, errors)
    //    WHY: Centralized app-level concerns, easier to debug
    //
    // 2. ActiveFilters - User-modifiable filter state
    //    WHY: All filter state in one place, easy to reset/share
    //
    // 3. UIState - UI component state (panels, dialogs, selections)
    //    WHY: UI concerns separate from data/business logic
    //
    // ANTI-PATTERN TO AVOID:
    // - Don't create variables like varIsLoading, varCurrentScreen, varSearchTerm
    // - Don't scatter related state across multiple variables
    // - Don't mix UI state with business logic state
    //
    // BENEFITS OF THIS STRUCTURE:
    // - Single source of truth for each concern
    // - Easy to reset state: Set(UIState, Patch(UIState, {SelectedItem: Blank()}))
    // - Intellisense shows all available fields: UIState. → autocomplete
    // - Debugging shows complete state: AppState record in Monitor
    //
    // ============================================================
    ```

    This philosophy section helps developers understand WHY the structure is this way.
  </action>
  <verify>
    Read src/App-OnStart-Minimal.fx entirely.
    Confirm documentation exists:
    - Variable structure philosophy section after line 27
    - Each variable (AppState, ActiveFilters, UIState) has:
      - Purpose statement
      - Complete schema with field names, types, descriptions
      - Usage examples (update, read, where used)

    Verify documentation accuracy:
    - Schema matches actual variable structure
    - Field descriptions are clear and accurate
    - Usage examples are syntactically correct Power Fx
  </verify>
  <done>
    Variable structure philosophy documented explaining three-variable approach.
    Each variable has complete schema documentation (field name, type, purpose, allowed values).
    Usage examples documented for update and read patterns.
    Anti-patterns documented (what NOT to do) with explanations.
    Benefits of structure documented (single source of truth, Intellisense, debugging).
  </done>
</task>

<task type="auto">
  <name>Validate Named Formula dependency chain</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
    Validate dependency chain in App-Formulas-Template.fx to ensure no circular references.

    DEPENDENCY CHAIN (expected linear flow):
    1. ThemeColors, Typography, Spacing, BorderRadius, AppConfig (no dependencies, pure static)
    2. UserProfile (depends on: Office365Users connector, User() function)
    3. UserRoles (depends on: UserProfile.Email, Office365Groups connector)
    4. UserPermissions (depends on: UserRoles.IsAdmin, UserRoles.IsManager, etc.)
    5. DateRanges (depends on: Today(), no user dependencies)

    CHECK FOR CIRCULAR REFERENCES:
    1. Does UserProfile reference UserRoles or UserPermissions? (would be circular)
    2. Does UserRoles reference UserPermissions? (would be circular)
    3. Do any static Named Formulas (ThemeColors, etc.) reference user formulas? (would be wrong)

    SCAN ENTIRE FILE for dependency patterns:
    ```bash
    # Check if UserProfile references UserRoles or UserPermissions
    grep -n "UserRoles\|UserPermissions" src/App-Formulas-Template.fx | grep -A5 -B5 "UserProfile"

    # Check if UserRoles references UserPermissions
    grep -n "UserPermissions" src/App-Formulas-Template.fx | grep -A5 -B5 "UserRoles"
    ```

    If circular references found, BREAK THEM by:
    - Moving computed value to separate Named Formula
    - Using UDF instead of direct reference
    - Reordering formulas to maintain linear dependency

    DOCUMENT dependencies in comments:
    ```powerfx
    // User Profile - Lazy-loaded from Office365Users connector
    // Depends on: Office365Users.MyProfileV2(), User().Email
    // Used by: UserRoles (for email-based group checks)
    UserProfile = With(...

    // User Roles - Azure AD Group membership
    // Depends on: UserProfile.Email, Office365Groups.ListGroupMembers()
    // Used by: UserPermissions, permission UDFs (HasRole, CanAccessRecord)
    UserRoles = {...

    // User Permissions - Derived from roles
    // Depends on: UserRoles.IsAdmin, UserRoles.IsManager, etc.
    // Used by: Permission UDFs (HasPermission), UI visibility checks
    UserPermissions = {...
    ```

    This makes dependencies explicit and prevents accidental circular references.
  </action>
  <verify>
    Read App-Formulas-Template.fx Named Formulas section (lines 1-276).
    Confirm dependency comments exist for:
    - UserProfile (lists: Office365Users connector, User() function)
    - UserRoles (lists: UserProfile.Email, Office365Groups connector)
    - UserPermissions (lists: UserRoles fields)
    - DateRanges (lists: Today(), no user dependencies)

    Verify no circular references:
    - UserProfile does NOT reference UserRoles or UserPermissions
    - UserRoles does NOT reference UserPermissions
    - Static formulas (ThemeColors, etc.) do NOT reference user formulas

    Create dependency graph visual:
    ```
    Office365Users → UserProfile → UserRoles → UserPermissions
    Today() → DateRanges
    (no dependencies) → ThemeColors, Typography, Spacing, BorderRadius, AppConfig
    ```
  </verify>
  <done>
    All Named Formulas have "Depends on:" and "Used by:" comments documenting dependencies.
    No circular references exist (verified by dependency graph).
    Dependency chain is linear: UserProfile → UserRoles → UserPermissions.
    Static Named Formulas (ThemeColors, Typography, etc.) have no dependencies on user formulas.
    Dependency graph documented in SUMMARY for future reference.
  </done>
</task>

</tasks>

<verification>
After implementation, verify variable optimization and dependency validation:

1. **AppState optimization:**
   - Read AppState variable structure
   - Confirm no redundant fields (LastError vs ErrorMessage resolved)
   - Confirm boolean fields use consistent Is*/Show* prefix
   - Confirm schema documentation exists and is accurate

2. **ActiveFilters optimization:**
   - Read ActiveFilters variable structure
   - Confirm no redundant inverse pairs (ActiveOnly vs IncludeArchived resolved)
   - Confirm date range fields exist (DateRangeFilter, CustomDateStart, CustomDateEnd)
   - Confirm schema documentation exists with allowed values

3. **UIState optimization:**
   - Read UIState variable structure
   - Confirm IsEditMode removed (redundant with FormMode)
   - Confirm clear separation of concerns (selection, panels, dialogs, forms)
   - Confirm schema documentation exists

4. **Variable documentation:**
   - Confirm variable structure philosophy section exists
   - Confirm each variable has purpose, schema, usage examples
   - Confirm anti-patterns documented (what NOT to do)

5. **Dependency validation:**
   - Read UserProfile, UserRoles, UserPermissions Named Formulas
   - Confirm "Depends on:" comments exist for each
   - Confirm no circular references (UserProfile doesn't reference UserRoles)
   - Create dependency graph and verify linear flow

6. **Cross-reference validation:**
   - Search Control-Patterns-Modern.fx for variable references
   - Confirm no broken references after optimization
   - Confirm FormMode used instead of IsEditMode
   - Confirm ActiveFilters fields match updated structure
</verification>

<success_criteria>
1. AppState structure logically consistent with no redundant fields, all documented
2. ActiveFilters structure optimized with date range support, no redundant inverse pairs
3. UIState structure follows single responsibility, IsEditMode removed
4. All variables have complete schema documentation (field name, type, purpose, usage)
5. Variable structure philosophy documented explaining three-variable approach
6. Named Formula dependency chain validated with no circular references
7. Dependency comments exist for UserProfile, UserRoles, UserPermissions
8. Control-Patterns-Modern.fx references updated for any changed variable fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-code-cleanup-standards/01-03-SUMMARY.md` documenting:
- Variable optimization changes (fields removed/added/renamed)
- Schema documentation locations (where developers find field definitions)
- Dependency graph visualization (UserProfile → UserRoles → UserPermissions)
- Circular reference validation results (should be none found)
- Any variable field migrations needed for existing apps using template
</output>
