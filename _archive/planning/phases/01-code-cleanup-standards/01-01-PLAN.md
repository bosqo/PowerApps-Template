---
phase: 01-code-cleanup-standards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/App-Formulas-Template.fx
autonomous: true

must_haves:
  truths:
    - "HasAnyRole() accepts unlimited comma-separated roles without hardcoded limit"
    - "IsOneOf() correctly validates values against comma-separated allowed list"
    - "IsValidEmail() rejects invalid formats (multiple @, spaces, missing parts)"
    - "All validation UDFs handle edge cases (empty strings, null values) without errors"
  artifacts:
    - path: "src/App-Formulas-Template.fx"
      provides: "Fixed UDF implementations"
      min_lines: 759
      contains: "HasAnyRole.*Filter.*Split"
  key_links:
    - from: "src/App-Formulas-Template.fx:324-330"
      to: "HasAnyRole() implementation"
      via: "Filter/CountRows pattern"
      pattern: "Filter.*Split.*HasRole"
    - from: "src/App-Formulas-Template.fx:575-581"
      to: "IsOneOf() implementation"
      via: "Filter/CountRows pattern"
      pattern: "Filter.*Split.*Lower.*Trim"
    - from: "src/App-Formulas-Template.fx:564-572"
      to: "IsValidEmail() implementation"
      via: "Enhanced validation checks"
      pattern: "CountRows.*Split.*@"
---

<objective>
Fix critical bugs in validation and permission UDFs to eliminate runtime errors and enable robust edge case handling.

Purpose: Ensure HasAnyRole(), IsOneOf(), and IsValidEmail() functions handle all inputs correctly without silent failures, preventing security bypasses and data validation errors.

Output: Corrected UDF implementations in App-Formulas-Template.fx with comprehensive edge case handling.
</objective>

<execution_context>
@D:\_Repo\repos\PowerApps-Vibe-Claude\.claude\workflows\execute-plan.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.claude\templates\summary.md
</execution_context>

<context>
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\PROJECT.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\ROADMAP.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\STATE.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\.planning\codebase\CONCERNS.md
@D:\_Repo\repos\PowerApps-Vibe-Claude\src\App-Formulas-Template.fx
</context>

<tasks>

<task type="auto">
  <name>Fix HasAnyRole() hardcoded 3-role limit</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
    Update HasAnyRole() function at lines 324-330 to remove hardcoded limit.

    Current implementation (CORRECT - already uses Filter/CountRows):
    ```powerfx
    HasAnyRole(roleNames: Text): Boolean =
        CountRows(
            Filter(
                Split(roleNames, ","),
                HasRole(Trim(Value))
            )
        ) > 0;
    ```

    This implementation ALREADY handles unlimited roles correctly using Filter() over Split() result.

    TASK: Verify implementation is correct (no hardcoded limit exists). Add comment documenting unlimited role support:
    ```powerfx
    // Check if user has any of the specified roles (comma-separated, unlimited count)
    // Example: HasAnyRole("Admin,Manager,HR") returns true if user has ANY of these roles
    HasAnyRole(roleNames: Text): Boolean =
        CountRows(
            Filter(
                Split(roleNames, ","),
                HasRole(Trim(Value))
            )
        ) > 0;
    ```

    Add edge case handling for empty input:
    ```powerfx
    HasAnyRole(roleNames: Text): Boolean =
        !IsBlank(roleNames) &&
        CountRows(
            Filter(
                Split(roleNames, ","),
                HasRole(Trim(Value))
            )
        ) > 0;
    ```
  </action>
  <verify>
    Read lines 324-330 of src/App-Formulas-Template.fx.
    Confirm Filter(Split()) pattern exists (not hardcoded First/Last/Index).
    Confirm empty string handling with IsBlank() check.
  </verify>
  <done>
    HasAnyRole() uses Filter/CountRows pattern without hardcoded limit.
    Empty string input returns false without error.
    Comment documents unlimited role support.
  </done>
</task>

<task type="auto">
  <name>Fix IsOneOf() incorrect operator usage</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
    Update IsOneOf() function at lines 575-581 to ensure correct validation logic.

    Current implementation:
    ```powerfx
    IsOneOf(value: Text, allowedValues: Text): Boolean =
        CountRows(
            Filter(
                Split(allowedValues, ","),
                Lower(Trim(Value)) = Lower(Coalesce(value, ""))
            )
        ) > 0;
    ```

    This implementation is CORRECT - uses Filter/CountRows pattern, not `in` operator.

    TASK: Verify implementation correctness and enhance edge case handling:
    1. Add null/blank value handling at function entry
    2. Add empty allowedValues handling
    3. Add clarifying comment

    Enhanced version:
    ```powerfx
    // Check if a value is in a set of allowed values (comma-separated)
    // Example: IsOneOf("draft", "draft,pending,active") returns true
    // Returns false for blank inputs or empty allowed list
    IsOneOf(value: Text, allowedValues: Text): Boolean =
        !IsBlank(value) &&
        !IsBlank(allowedValues) &&
        CountRows(
            Filter(
                Split(allowedValues, ","),
                Lower(Trim(Value)) = Lower(Trim(value))
            )
        ) > 0;
    ```

    Note: Removed Coalesce() and added explicit IsBlank() checks for clarity.
  </action>
  <verify>
    Read lines 575-581 of src/App-Formulas-Template.fx.
    Confirm Filter(Split()) pattern with Lower/Trim comparison.
    Confirm IsBlank() checks for both parameters.
    Test edge cases: IsOneOf("", "a,b"), IsOneOf("a", ""), IsOneOf("test", "test,other").
  </verify>
  <done>
    IsOneOf() uses Filter/CountRows pattern (not `in` operator).
    Empty/blank inputs return false without error.
    Comment documents usage with example.
  </done>
</task>

<task type="auto">
  <name>Strengthen IsValidEmail() validation</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
    Update IsValidEmail() function at lines 564-572 to reject invalid email formats.

    Current implementation allows multiple @ symbols and doesn't validate enough edge cases.

    REPLACE with strengthened validation:
    ```powerfx
    // Validate email format
    // Rejects: multiple @, spaces, missing local/domain parts, invalid domain format
    // Example valid: user@example.com, first.last@company.co.uk
    // Example invalid: user@@example.com, user @domain.com, @example.com, user@
    IsValidEmail(email: Text): Boolean =
        !IsBlank(email) &&
        // No spaces allowed
        !IsMatch(email, " ") &&
        // Exactly one @ symbol
        CountRows(Split(email, "@")) = 2 &&
        // Local part (before @) must be at least 1 character
        Len(First(Split(email, "@")).Value) >= 1 &&
        // Domain part (after @) must be at least 4 characters (a.bc minimum)
        Len(Last(Split(email, "@")).Value) >= 4 &&
        // Domain must contain at least one dot
        IsMatch(Last(Split(email, "@")).Value, "\.") &&
        // Domain must not start or end with dot
        !StartsWith(Last(Split(email, "@")).Value, ".") &&
        !EndsWith(Last(Split(email, "@")).Value, ".") &&
        // Domain must not start or end with hyphen
        !StartsWith(Last(Split(email, "@")).Value, "-") &&
        !EndsWith(Last(Split(email, "@")).Value, "-") &&
        // Local part must not start or end with dot
        !StartsWith(First(Split(email, "@")).Value, ".") &&
        !EndsWith(First(Split(email, "@")).Value, ".");
    ```

    This prevents common invalid formats:
    - `user@@example.com` (multiple @) → CountRows check fails
    - `user @example.com` (space) → IsMatch check fails
    - `@example.com` (missing local) → Len check fails
    - `user@` (missing domain) → Len check fails
    - `user@.com` (domain starts with dot) → StartsWith check fails
    - `user@example.` (domain ends with dot) → EndsWith check fails
  </action>
  <verify>
    Read lines 564-572 of src/App-Formulas-Template.fx.
    Confirm validation includes:
    - CountRows(Split(email, "@")) = 2 (exactly one @)
    - IsMatch check for spaces (rejects "user @domain.com")
    - StartsWith/EndsWith checks for dots and hyphens
    - Minimum length validation for local and domain parts
  </verify>
  <done>
    IsValidEmail() rejects multiple @ symbols (test: "user@@example.com" returns false).
    IsValidEmail() rejects spaces (test: "user @domain.com" returns false).
    IsValidEmail() rejects missing parts (test: "@example.com" and "user@" return false).
    IsValidEmail() rejects invalid domain formats (test: "user@.com", "user@example." return false).
    Valid emails pass (test: "user@example.com", "first.last@company.co.uk" return true).
  </done>
</task>

<task type="auto">
  <name>Validate all UDF edge case handling</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
    Audit all validation UDFs in the validation section (lines 560-594) for edge case handling.

    UDFs to check:
    1. IsValidEmail() - already fixed in previous task
    2. IsOneOf() - already fixed in previous task
    3. IsAlphanumeric() - verify handles empty/null
    4. IsNotPastDate() - verify handles blank dates
    5. Any other validation UDFs

    For each UDF, ensure:
    - IsBlank() or similar check at entry point for null/empty inputs
    - Coalesce() used where null handling needed
    - Boolean return (no Blank() return types)
    - Clear comments documenting expected inputs and edge case behavior

    Example pattern to verify exists:
    ```powerfx
    // Good: Handles blank input
    IsAlphanumeric(text: Text): Boolean =
        !IsBlank(text) &&
        IsMatch(text, "^[a-zA-Z0-9]+$");

    // Good: Handles blank date
    IsNotPastDate(dateValue: Date): Boolean =
        !IsBlank(dateValue) &&
        dateValue >= Today();
    ```

    If any UDF missing edge case handling, add IsBlank() checks following above pattern.
  </action>
  <verify>
    Read validation section (lines 560-594) of src/App-Formulas-Template.fx.
    For each validation UDF, confirm:
    - IsBlank() check exists for nullable parameters
    - Boolean return type (not Blank())
    - Comment documents edge case behavior

    Test edge cases programmatically if possible:
    - IsAlphanumeric("") returns false
    - IsNotPastDate(Blank()) returns false
  </verify>
  <done>
    All validation UDFs include IsBlank() checks for nullable inputs.
    No validation UDF returns Blank() (all return Boolean true/false).
    Comments document edge case behavior (empty strings, null values).
    Edge case testing confirms no runtime errors for null/empty inputs.
  </done>
</task>

</tasks>

<verification>
After implementation, verify all bug fixes:

1. **HasAnyRole() unlimited roles:**
   - Call `HasAnyRole("Admin,Manager,HR,GF,Sachbearbeiter,User")` with 6 roles
   - Confirm returns true if user has ANY of these roles (not just first 3)

2. **IsOneOf() correct validation:**
   - Call `IsOneOf("draft", "draft,pending,active")` → expect true
   - Call `IsOneOf("invalid", "draft,pending")` → expect false
   - Call `IsOneOf("", "draft,pending")` → expect false
   - Call `IsOneOf("draft", "")` → expect false

3. **IsValidEmail() strengthened:**
   - Call `IsValidEmail("user@example.com")` → expect true
   - Call `IsValidEmail("user@@example.com")` → expect false (multiple @)
   - Call `IsValidEmail("user @example.com")` → expect false (space)
   - Call `IsValidEmail("@example.com")` → expect false (missing local)
   - Call `IsValidEmail("user@")` → expect false (missing domain)

4. **Edge case handling:**
   - Call all validation UDFs with empty strings → expect false (not error)
   - Call all validation UDFs with null/Blank() → expect false (not error)

No delegation warnings should appear for these UDFs (they are pure functions, not data operations).
</verification>

<success_criteria>
1. HasAnyRole() handles unlimited comma-separated roles without hardcoded limit
2. IsOneOf() uses correct Filter/CountRows pattern (not broken `in` operator)
3. IsValidEmail() rejects all documented invalid formats (multiple @, spaces, etc.)
4. All validation UDFs handle empty strings and null values without runtime errors
5. No regression in existing functionality (UDFs still return correct results for valid inputs)
</success_criteria>

<output>
After completion, create `.planning/phases/01-code-cleanup-standards/01-01-SUMMARY.md` documenting:
- Specific UDF changes made
- Edge cases now handled
- Test results for validation scenarios
- Any unexpected findings or additional bugs discovered
</output>
