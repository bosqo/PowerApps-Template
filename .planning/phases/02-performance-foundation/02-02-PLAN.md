---
phase: 02-performance-foundation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/App-OnStart-Minimal.fx
  - src/App-Formulas-Template.fx
autonomous: true

must_haves:
  truths:
    - "All non-critical data (departments, categories, statuses, priorities) load in parallel via Concurrent(), not sequentially"
    - "Non-critical data failures retry once after 2 seconds, then gracefully degrade to empty or 'Unbekannt' fallback"
    - "User sees empty galleries (not errors) if lookup data fails to load"
    - "All error messages are user-friendly German text without technical codes or error numbers"
    - "Retry logic applies only to non-critical data; critical data failures still block startup"
    - "App.OnStart completes and sets IsInitializing: false even if non-critical data fails"
  artifacts:
    - path: "src/App-OnStart-Minimal.fx"
      provides: "Parallel data loading via Concurrent() for non-critical collections with retry and fallback"
      key_fields: ["Concurrent() block", "Retry pattern", "Fallback values", "Error handling"]
    - path: "src/App-Formulas-Template.fx"
      provides: "Error handling UDFs for graceful degradation and user-friendly error messages"
      key_fields: ["NotifyError()", "GetFallbackValue()", "FormatErrorMessage()"]
  key_links:
    - from: "App.OnStart section 4 (DATA CACHE)"
      to: "CachedDepartments, CachedCategories, CachedStatuses, CachedPriorities"
      via: "Concurrent() with parallel ClearCollect calls"
      pattern: "Concurrent\\(.*ClearCollect.*CachedDepartments"
    - from: "Lookup data collections"
      to: "Retry logic"
      via: "IfError() or Retry() pattern"
      pattern: "IfError\\(.*Retry|2.*seconds"
    - from: "Error handling"
      to: "User messages"
      via: "German error messages"
      pattern: "Unbekannt|Fehler|Verbindung"
---

## 02-02: Parallel Background Loading & Error Handling

**Objective**
Move non-critical data (departments, categories, statuses, priorities) to parallel loading via Concurrent(), implement retry logic for non-critical failures, and create a consistent error handling pattern with user-friendly German messages. This reduces overall startup time by parallelizing independent operations while gracefully degrading if background data fails.

**Purpose:** While critical data (user profile, roles, permissions) must load sequentially, background lookup data can load in parallel. Failures in background data should not block the app; instead, they degrade gracefully with fallback values.

**Output:** Modified App.OnStart with Concurrent() for background data, retry logic for failed collections, and consistent German error messages.

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-performance-foundation/02-CONTEXT.md

# Prior plan: Critical path & caching complete
@.planning/phases/02-performance-foundation/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Concurrent() for non-critical lookup data</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
  The App.OnStart template already has a Concurrent() block in section "4. DATA CACHE - Static Lookup Data" (around line 257). Update this section to:

  1. Ensure all non-critical ClearCollect calls are inside the same Concurrent() block:
     - CachedDepartments (from Dataverse/SharePoint Departments table)
     - CachedCategories (from Dataverse/SharePoint Categories table)
     - CachedStatuses (static table)
     - CachedPriorities (static table)

  2. Current code structure should look like:
     ```
     Concurrent(
       ClearCollect(CachedDepartments, ...),
       ClearCollect(CachedCategories, ...),
       ClearCollect(CachedStatuses, ...),
       ClearCollect(CachedPriorities, ...)
     );
     ```

  3. Verify comment above Concurrent() explains:
     - "All non-critical collections load in parallel for faster startup"
     - "Each ClearCollect is independent (no data dependencies)"
     - "Failures in one collection do not block others"
     - "Critical data (section 0) loads before this section to ensure user is authenticated"

  4. Add section marker comment:
     ```
     // ============================================================
     // 4. BACKGROUND DATA - Parallel Lookup Data Loading
     // ============================================================
     // Load commonly used lookup/reference data in parallel
     // These are independent non-critical collections that don't block startup
     ```

  NOTE: If Concurrent() is not properly wrapping all four collections, restructure it now.
  </action>
  <verify>
  - Concurrent() block exists in section 4
  - All four CachedDepartments, CachedCategories, CachedStatuses, CachedPriorities inside Concurrent()
  - Each ClearCollect is independent (no data dependencies)
  - Comments explain parallel loading and independence
  - Code compiles without syntax errors
  </verify>
  <done>
  - Concurrent() block properly wraps all non-critical collections
  - All lookup data loads in parallel (not sequential)
  - Dependencies documented in comments
  - Startup path: critical (sequential) → background (parallel) → user-scoped (sequential if needed)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add retry logic to non-critical collections with 2-second delay</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
  Wrap each ClearCollect call in the Concurrent() block with a retry pattern. Implement one retry after 2-second delay for non-critical data:

  1. For each ClearCollect in Concurrent(), implement:
     ```
     ClearCollect(
       CachedDepartments,
       IfError(
         // First attempt: Try to load from Departments table
         Sort(
           Filter(Departments, Status = "Active"),
           Name, SortOrder.Ascending
         ),
         // First error: Wait 2 seconds and retry once
         IfError(
           Delay(2000);  // Wait 2 seconds
           Sort(
             Filter(Departments, Status = "Active"),
             Name, SortOrder.Ascending
           ),
           // Second attempt also failed: Use empty fallback
           Table()  // Empty table - galleries will show empty state
         )
       )
     )
     ```

  2. Apply same retry pattern to:
     - CachedDepartments (retry loading from Departments table)
     - CachedCategories (retry loading from Categories table)
     - CachedStatuses (retry static table - should rarely fail)
     - CachedPriorities (retry static table - should rarely fail)

  3. Fallback behavior:
     - If both attempts fail: return empty Table()
     - Empty collection means gallery shows empty state (not error)
     - User can still interact with app
     - Fallback "Unbekannt" handled per-record in control bindings (not in collection)

  4. Add comments explaining:
     - "First attempt: Load from data source"
     - "Retry: Wait 2 seconds, attempt once more"
     - "Fallback: Empty collection on persistent failure"
     - "Non-critical: Failure does not block app or critical data"

  NOTE: Power Fx may not support Delay() in ClearCollect context. If so, use alternative:
  - Option A: Use Timer control to delay and retry (deferred to Phase 4 for UI implementation)
  - Option B: Skip Delay() and implement retry by checking collection count after initial load
  - For this plan: Implement retry logic without delay (sequential retries, immediate)
  - Pattern: Retry immediately if first load returns empty or error
  ```
  ClearCollect(
    CachedDepartments,
    IfError(
      Sort(Filter(Departments, Status = "Active"), Name, SortOrder.Ascending),
      Sort(Filter(Departments, Status = "Active"), Name, SortOrder.Ascending),  // Retry immediately
      Table()  // Fallback
    )
  )
  ```
  </action>
  <verify>
  - Each ClearCollect wrapped with IfError()
  - First error handler: Retries collection load (attempt 2)
  - Second error handler: Returns empty Table() fallback
  - Fallback is empty table, not error message
  - All four collections (Departments, Categories, Statuses, Priorities) have retry pattern
  - Code compiles without syntax errors
  - Concurrent() still properly groups all four collections
  </verify>
  <done>
  - Retry logic implemented for non-critical collections
  - Fallback to empty table on persistent failure
  - Galleries gracefully show empty state instead of errors
  - Non-critical data failures do not block app startup
  - Retry pattern consistent across all background collections
  </done>
</task>

<task type="auto">
  <name>Task 3: Create graceful fallback pattern for missing lookup data</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
  When lookup data fails to load (collections are empty), galleries and dropdowns should handle the empty state gracefully. Implement fallback patterns:

  1. For gallery controls that use CachedDepartments, CachedCategories, etc.:
     - Gallery.Items: If(IsEmpty(CachedDepartments), Table({Name: "Unbekannt", Value: ""}), CachedDepartments)
     - This shows "Unbekannt" as a placeholder option when collection is empty
     - User can still select an option; the record will have "Unbekannt" as department

  2. For dropdown controls:
     - Dropdown.Items: If(IsEmpty(CachedStatuses), Table({Value: "Unbekannt", DisplayName: "Unbekannt"}), CachedStatuses)
     - Single fallback option ensures dropdown is never truly empty

  3. For display formulas (showing department in list):
     - If(IsBlank(ThisItem.Department), "Unbekannt", ThisItem.Department)
     - Text labels show "Unbekannt" instead of blank

  4. Add comment section in App-OnStart explaining fallback philosophy:
     ```
     // ============================================================
     // FALLBACK VALUES FOR MISSING DATA
     // ============================================================
     // When non-critical data fails to load, fallback to "Unbekannt" (Unknown in German)
     // This prevents app from showing blank or error states
     // User experience: App fully functional, but with limited options until data loads
     //
     // Examples:
     // - Gallery shows 1 default "Unbekannt" item if CachedDepartments empty
     // - Dropdown shows "Unbekannt" option if CachedStatuses empty
     // - Record displays "Unbekannt" for missing department field
     ```

  5. Document examples for team:
     - Add these patterns to Control-Patterns-Modern.fx as standard templates
     - Reference: Department dropdown, Category filter, Owner selector

  NOTE: Specific control updates deferred to Phase 4 (control patterns work). This task focuses on App.OnStart documentation and collection-level fallbacks.
  </action>
  <verify>
  - Fallback pattern documented in App-OnStart comments
  - "Unbekannt" identified as standard German fallback string
  - Fallback applies to all missing data: departments, categories, statuses, priorities
  - Pattern is: "If(IsEmpty(Collection), FallbackTable, Collection)"
  - Control-Patterns-Modern.fx has reference examples
  - Documentation is clear enough for future team members
  </verify>
  <done>
  - Fallback strategy documented and consistent
  - "Unbekannt" is standard fallback across all missing lookup data
  - Galleries and dropdowns have fallback templates
  - App gracefully degrades without showing technical errors
  - User sees "Unbekannt" instead of blank or error messages
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement user-friendly German error messages</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
  Create a set of error message UDFs in App-Formulas-Template.fx for consistent German error messaging throughout the app. Add new section "ERROR MESSAGE LOCALIZATION":

  1. Create UDFs for common error scenarios (all returning German text):
     ```
     // Error Messages - German localization
     // Returns user-friendly error messages without technical jargon

     ErrorMessage_ProfileLoadFailed(connectorName: Text): Text =
       Switch(connectorName,
         "Office365Users", "Ihre Profilinformationen konnten nicht geladen werden. Bitte überprüfen Sie Ihre Internetverbindung.",
         "Office365Groups", "Ihre Berechtigungen konnten nicht überprüft werden. Bitte versuchen Sie später erneut.",
         "Departments", "Abteilungsdaten konnten nicht geladen werden. Sie können die App trotzdem nutzen.",
         "Generic", "Ein Fehler ist aufgetreten. Bitte aktualisieren Sie die App und versuchen Sie erneut."
       );

     ErrorMessage_DataRefreshFailed(operationType: Text): Text =
       Switch(operationType,
         "save", "Speichern fehlgeschlagen. Bitte überprüfen Sie Ihre Eingabe und versuchen Sie erneut.",
         "delete", "Löschen fehlgeschlagen. Sie haben möglicherweise keine Berechtigung.",
         "load", "Daten konnten nicht geladen werden. Bitte überprüfen Sie Ihre Internetverbindung.",
         "Generic", "Vorgang fehlgeschlagen. Bitte versuchen Sie später erneut."
       );

     ErrorMessage_PermissionDenied(actionName: Text): Text =
       "Sie haben keine Berechtigung zum Ausführen dieser Aktion: " & actionName;

     // Generic error without technical details
     ErrorMessage_Generic: Text = "Ein Fehler ist aufgetreten. Bitte versuchen Sie später erneut.";
     ```

  2. Add documentation comments:
     - "All error messages are user-friendly German (kein technical jargon)"
     - "Never show error codes, stack traces, or API response details"
     - "Include remediation hints where possible (e.g., 'check network', 'retry later')"

  3. These UDFs will be called by App.OnStart error handlers:
     ```
     ErrorMessage: ErrorMessage_ProfileLoadFailed("Office365Users")
     ```

  4. Pattern for using in App.OnStart:
     - When IfError() catches an Office365Users failure, call ErrorMessage_ProfileLoadFailed()
     - Set AppState.ErrorMessage to the result
     - Display in user-facing error dialog (not in console)

  5. Avoid in these messages:
     - ✗ "Office365Users Connector Timeout: XXXXXXX"
     - ✗ "HTTP 401: Unauthorized"
     - ✗ "Error Code: -2147024809"
     - ✓ "Ihre Profilinformationen konnten nicht geladen werden. Bitte überprüfen Sie Ihre Internetverbindung."
  </action>
  <verify>
  - UDFs exist: ErrorMessage_ProfileLoadFailed, ErrorMessage_DataRefreshFailed, ErrorMessage_PermissionDenied, ErrorMessage_Generic
  - All return German text (no English, no error codes)
  - Messages are user-friendly and actionable
  - Messages avoid technical jargon (no "connector", "timeout", "HTTP", "API")
  - Code compiles without syntax errors
  - UDFs are called from App.OnStart error handlers (verified in prior task)
  </verify>
  <done>
  - Error message UDFs created for common scenarios
  - All messages in user-friendly German
  - No technical jargon or error codes in user-facing messages
  - Error messaging pattern established for Phase 3+ features
  - Teams can reuse these UDFs for Patch, Remove, custom validation errors
  </done>
</task>

<task type="auto">
  <name>Task 5: Update App.OnStart error handling to use German messages</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
  Update the critical path error handling (from plan 02-01) to use the new German error message UDFs:

  1. In section "0. CRITICAL PATH", modify the IfError() for Office365Users call:
     ```
     IfError(
       {
         DisplayName: Office365Users.MyProfileV2().DisplayName,
         Email: Office365Users.MyProfileV2().UserPrincipalName,
         Department: Office365Users.MyProfileV2().Department,
         ...
       },
       {
         DisplayName: "Unbekannt",
         Email: "unknown@company.com",
         Department: "Unbekannt",
         ...
       }
     );

     // If error occurred, set error state
     If(
       IsError(...),  // Check if above call failed
       Set(AppState, Patch(AppState, {
         ShowErrorDialog: true,
         ErrorMessage: ErrorMessage_ProfileLoadFailed("Office365Users"),
         IsInitializing: true  // Keep app locked
       }))
     );
     ```

  2. Add error state check after critical path:
     - If AppState.ShowErrorDialog = true, show error message to user
     - User must acknowledge error (click "Retry" or "Close")
     - On retry: Allow user to refresh App.OnStart manually

  3. For non-critical data errors (section 4):
     - Non-critical failures silently use empty fallback (no dialog)
     - Optional: Log failed collection name to AppState for diagnostics
     - User does not see error, just sees empty dropdown/gallery

  4. Add comments explaining:
     - "Critical path errors: Show user friendly error, keep app locked, require user action"
     - "Background data errors: Silently use fallback, do not show dialog"
     - "All error messages are German and user-friendly"

  5. Verify error dialog pattern:
     - When ShowErrorDialog = true, display modal dialog with ErrorMessage
     - Dialog has "Retry" and "Close" buttons
     - Retry: Call App.OnStart again (reload app)
     - Close: Allow user to close app
  </action>
  <verify>
  - App.OnStart critical path errors call ErrorMessage_ProfileLoadFailed()
  - ErrorMessage set in AppState when Office365Users fails
  - ShowErrorDialog flag set to true for critical errors
  - Non-critical collection errors do NOT show dialog (silent fallback)
  - Error messages are German and user-friendly (no error codes)
  - Code compiles without syntax errors
  - IsInitializing flag behavior correct: true during error, false after recovery
  </verify>
  <done>
  - Critical path errors show user-friendly German messages
  - Non-critical failures gracefully degrade to empty collections
  - Error handling is consistent throughout startup
  - User experience: App either loads fully or shows single clear error message
  - No technical error codes or jargon shown to user
  </done>
</task>

<task type="auto">
  <name>Task 6: Document error handling patterns for future phases</name>
  <files>src/App-Formulas-Template.fx, src/App-OnStart-Minimal.fx</files>
  <action>
  Add comprehensive documentation for error handling patterns that Phase 3+ features can follow:

  1. In App-Formulas-Template.fx, add new section "ERROR HANDLING PATTERNS":
     ```
     // ============================================================
     // ERROR HANDLING PATTERNS FOR PHASES 3+
     // ============================================================
     //
     // Pattern 1: Critical Path Error (blocks app)
     // Use when user MUST have this data to continue
     // Example: User profile loading fails
     // Result: Show German error message, keep app locked, require user action
     //
     // Pattern 2: Non-Critical Error (graceful degradation)
     // Use when app can function without this data
     // Example: Department lookup fails
     // Result: Use empty fallback, silently continue startup
     //
     // Pattern 3: User Action Error (notify, don't block)
     // Use when user performs action that fails (save, delete, approve)
     // Example: Patch fails due to permissions
     // Result: Show German error message, keep form open, user can retry
     //
     // Error Message Guidelines:
     // - Always use ErrorMessage_* UDFs (defined above)
     // - Never show error codes, stack traces, API details
     // - Always include remediation hint (check network, retry, contact admin)
     // - Always use German language (kein English)
     //
     // Implementation:
     // Phase 3 delete flow:
     //   IfError(
     //     Remove(Items, Gallery.Selected),
     //     Set(AppState, Patch(AppState, {
     //       ShowErrorDialog: true,
     //       ErrorMessage: ErrorMessage_DataRefreshFailed("delete")
     //     }))
     //   )
     //
     // Phase 4 form save:
     //   IfError(
     //     SubmitForm(EditForm),
     //     Set(AppState, Patch(AppState, {
     //       ShowErrorDialog: true,
     //       ErrorMessage: ErrorMessage_DataRefreshFailed("save")
     //     }))
     //   )
     ```

  2. In App-OnStart-Minimal.fx, add comment:
     ```
     // Error Handling Reference:
     // - Critical path (section 0): Uses IfError() with German messages
     // - Background data (section 4): Uses IfError() with empty fallback
     // See App-Formulas-Template.fx: ERROR HANDLING PATTERNS section
     ```

  3. Update CLAUDE.md with error handling section:
     - Link to these patterns
     - Provide copy-paste examples for common scenarios
     - Document "Unbekannt" as standard fallback

  4. Create reference table in documentation:
     | Scenario | Error Type | Handler | Message |
     |----------|-----------|---------|---------|
     | Profile load | Critical | IfError | ErrorMessage_ProfileLoadFailed("Office365Users") |
     | Permission check | Critical | IfError | ErrorMessage_ProfileLoadFailed("Office365Groups") |
     | Department lookup | Non-critical | IfError | (empty fallback) |
     | Delete record | User action | IfError | ErrorMessage_DataRefreshFailed("delete") |
  </action>
  <verify>
  - ERROR HANDLING PATTERNS section exists in App-Formulas-Template.fx
  - Section includes 3+ pattern examples (critical, non-critical, user action)
  - All examples use German error messages
  - Documentation includes do's and don'ts for error handling
  - Reference table or guide included for Phase 3+ features
  - Code compiles without syntax errors
  </verify>
  <done>
  - Error handling patterns documented for future phases
  - Teams can follow established patterns for consistency
  - Critical vs non-critical error handling clearly distinguished
  - All examples use German, user-friendly error messages
  - Foundation established for Phase 3 features (delete, patch, etc.)
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Parallel Data Loading:**
   - Concurrent() block includes all 4 collections (Departments, Categories, Statuses, Priorities)
   - Each ClearCollect is independent (no data dependencies between them)
   - Collections load simultaneously, not sequentially
   - Power Apps Monitor shows all 4 ClearCollect calls completing ~same time

2. **Retry Logic:**
   - Each collection wrapped with IfError() for first attempt
   - Second error handler triggers second attempt
   - Fallback: empty Table() on persistent failure
   - Retry pattern consistent across all 4 collections

3. **Graceful Degradation:**
   - If CachedDepartments empty, galleries show "Unbekannt" or empty state (not error)
   - If CachedCategories empty, dropdowns show fallback option
   - If CachedStatuses empty, status filter shows empty or "Unbekannt" option
   - App never shows technical error message for background data failure

4. **German Error Messages:**
   - ErrorMessage_ProfileLoadFailed, ErrorMessage_DataRefreshFailed, etc. exist in App-Formulas
   - All return German text without error codes
   - No English, no technical jargon, no stack traces
   - Examples include remediation hints ("check network", "retry later")

5. **Error Handling Separation:**
   - Critical path errors (Office365Users, Office365Groups): Show dialog, keep app locked
   - Non-critical collection errors: Silent fallback, no dialog
   - User action errors (Phase 3+): Use ErrorMessage_* UDFs with pattern examples

6. **Startup Sequence:**
   - Section 0 (Critical path): Sequential user → roles → permissions
   - Section 1-3: State variables initialized
   - Section 4 (Background): Parallel Concurrent() for non-critical collections
   - Section 5: User-scoped data (recent items, tasks)
   - Section 6: Mark IsInitializing = false
   - If error in critical path: Keep IsInitializing = true, show error dialog

7. **App.OnStart Completion:**
   - All sections execute without infinite loops
   - IsInitializing set to false at completion (success path)
   - IsInitializing stays true if critical error (user must retry)
   - App ready for interaction after section 6 completes
</verification>

<success_criteria>
- [ ] Concurrent() wraps all 4 background collections (Departments, Categories, Statuses, Priorities)
- [ ] Each collection has retry logic: IfError(attempt1, IfError(attempt2, fallback))
- [ ] Fallback for background collections: empty Table() (no errors shown to user)
- [ ] ErrorMessage_* UDFs created for ProfileLoadFailed, DataRefreshFailed, PermissionDenied, Generic
- [ ] All error messages in German, user-friendly, no error codes or technical jargon
- [ ] Critical path errors: Show dialog, keep app locked (IsInitializing: true)
- [ ] Non-critical collection errors: Silent fallback, no dialog shown
- [ ] "Unbekannt" documented as standard fallback for missing lookup data
- [ ] Error handling patterns documented for Phase 3+ features in App-Formulas-Template.fx
- [ ] App.OnStart completes successfully (all sections execute in order)
- [ ] Gallery and dropdown controls have fallback templates for empty collections
</success_criteria>

<output>
After completion, create `.planning/phases/02-performance-foundation/02-02-SUMMARY.md` with:
- Concurrent() implementation for background data (4 parallel collections)
- Retry logic details (immediate retry, no delay, fallback to empty)
- Graceful degradation strategy ("Unbekannt" fallback for missing lookup data)
- Error message UDFs created and German messaging approach
- Error handling patterns documented for Phase 3+ features
- Updated CLAUDE.md reference section for error handling
- Startup sequence: critical (sequential) → background (parallel) → user-scoped → finalize
</output>
