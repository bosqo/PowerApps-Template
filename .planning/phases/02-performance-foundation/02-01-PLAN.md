---
phase: 02-performance-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/App-Formulas-Template.fx
  - src/App-OnStart-Minimal.fx
autonomous: true

must_haves:
  truths:
    - "User profile loads from Office365Users.MyProfileV2 only once per app session, cached for subsequent access"
    - "User roles are determined by Office365Groups membership check, cached after first determination"
    - "User permissions are calculated from cached roles without redundant Office365 API calls"
    - "Critical data (user profile, roles, permissions) loads sequentially before app allows user interaction"
    - "App blocks user interaction (AppState.IsInitializing = true) until critical path completes"
    - "All Office365 connector calls have graceful error handling with user-friendly German messages"
  artifacts:
    - path: "src/App-Formulas-Template.fx"
      provides: "Named Formulas for UserProfile, UserRoles, UserPermissions with caching logic"
      key_fields: ["UserProfile (with cache)", "UserRoles (with cache)", "UserPermissions (with cache)", "CacheTimestamp"]
    - path: "src/App-OnStart-Minimal.fx"
      provides: "Sequential critical path loading (user → roles → permissions) with cache initialization"
      key_fields: ["Cache collections", "Error handling for Office365 failures", "IsInitializing flag management"]
  key_links:
    - from: "App.OnStart"
      to: "Office365Users.MyProfileV2()"
      via: "ClearCollect or variable assignment"
      pattern: "ClearCollect.*UserProfileCache"
    - from: "UserProfile Named Formula"
      to: "UserProfileCache collection"
      via: "Cache lookup (if cache exists, use it; else call API)"
      pattern: "If\\(IsBlank.*CachedProfile.*Office365Users"
    - from: "UserRoles Named Formula"
      to: "Office365Groups.CheckMembershipAsync()"
      via: "Cached group membership results"
      pattern: "If\\(IsBlank.*CachedRoles.*Office365Groups"
    - from: "UserPermissions Named Formula"
      to: "UserRoles"
      via: "Derived permissions from cached roles (no API call)"
      pattern: "UserRoles\\."
---

## 02-01: Critical Path & Caching

**Objective**
Implement sequential loading of user profile → roles → permissions with Office365 API caching to achieve the critical path for app startup. This ensures the user is identified and authorized before app becomes interactive, while eliminating redundant API calls between sessions.

**Purpose:** Critical data must be available and cached before the app can safely function. This plan ensures identity and authorization are loaded once and reused.

**Output:** Modified App-Formulas-Template.fx with caching logic, modified App-OnStart-Minimal.fx with sequential critical path and cache initialization.

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-performance-foundation/02-CONTEXT.md

# Phase 1 complete - clean foundation established
@.planning/phases/01-code-cleanup-standards/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement UserProfile caching in Named Formulas</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
  In App-Formulas-Template.fx, after the AppConfig Named Formula definition, create a new section called "USER PROFILE CACHING" with these elements:

  1. Create a CachedUserProfile Named Formula that checks for cached data:
     - First checks if a collection called "CachedProfileCache" exists and has data
     - If cache exists and is less than 5 minutes old (compare to CacheTimestamp), return cached value
     - If cache is stale or empty, call Office365Users.MyProfileV2() to fetch fresh data
     - Store result in a temporal variable or use direct return
     - Pattern: If(IsBlank(CachedProfileCache), {/* cache miss */}, {/* cache hit */})

  2. Annotate with comments explaining:
     - Cache invalidation happens after 5 minutes (AppConfig.CacheExpiryMinutes)
     - Session-scoped cache: new app session = fresh data
     - Called by UserProfile Named Formula

  3. Example structure (adapt to Power Fx syntax):
     ```
     // USER PROFILE CACHING
     // Returns user profile from cache if available (< 5 min old)
     // or fetches from Office365Users.MyProfileV2() if cache miss

     CachedUserProfile =
       If(
         IsBlank(CachedProfileCache) || Now() - CacheTimestamp > TimeValue("0:5:0"),
         /* Cache miss or expired - fetch from API */
         {
           DisplayName: Office365Users.MyProfileV2().DisplayName,
           Email: Office365Users.MyProfileV2().UserPrincipalName,
           Department: Office365Users.MyProfileV2().Department,
           JobTitle: Office365Users.MyProfileV2().JobTitle,
           MobilePhone: Office365Users.MyProfileV2().MobilePhone
         },
         /* Cache hit - return cached value */
         CachedProfileCache
       );
     ```

  4. Note: This is a Named Formula definition, not imperative code. It will be evaluated lazily in App.OnStart step.
  </action>
  <verify>
  - CachedUserProfile Named Formula exists in App.Formulas
  - Formula references CachedProfileCache collection
  - Formula references CacheTimestamp for TTL check
  - Formula calls Office365Users.MyProfileV2() with fallback structure
  - Code compiles without syntax errors in Power Apps editor
  </verify>
  <done>
  - CachedUserProfile Named Formula defined with cache-aware logic
  - TTL (5 minutes) documented in comments
  - API call happens only on cache miss
  - Subsequent reads use cached value
  </done>
</task>

<task type="auto">
  <name>Task 2: Initialize profile cache and implement sequential load in App.OnStart</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
  Modify App.OnStart to implement the critical path: user profile → caching → roles → permissions.

  BEFORE the "4. DATA CACHE - Static Lookup Data" section (around line 248), add a new section "0. CRITICAL PATH - SEQUENTIAL USER IDENTITY & AUTHORIZATION":

  1. Initialize cache collections:
     ```
     // Initialize empty cache collections that will hold Office365 results
     Set(CacheTimestamp, Now());
     ClearCollect(CachedProfileCache, {});  // Will be populated by Office365Users call
     ClearCollect(CachedRolesCache, {});    // Will be populated by Office365Groups calls
     ```

  2. Implement sequential critical path (NOT using Concurrent):
     ```
     // CRITICAL PATH: Sequential load ensures permissions calculated from complete role data
     // Step 1: Fetch user profile from Office365Users
     ClearCollect(
       CachedProfileCache,
       {
         DisplayName: Office365Users.MyProfileV2().DisplayName,
         Email: Office365Users.MyProfileV2().UserPrincipalName,
         Department: Office365Users.MyProfileV2().Department,
         JobTitle: Office365Users.MyProfileV2().JobTitle,
         MobilePhone: Office365Users.MyProfileV2().MobilePhone
       }
     );

     // Update cache timestamp
     Set(CacheTimestamp, Now());

     // Step 2: Check user roles from cached profile (this reads the cache)
     // Roles are determined in UserRoles Named Formula using Office365Groups
     // Named Formula is lazy-evaluated here to trigger role check
     Set(AppState, Patch(AppState, {UserRoles: UserRoles}));

     // Step 3: Calculate permissions from roles (this reads UserRoles)
     // Permissions are derived from roles in UserPermissions Named Formula
     // This completes the critical path without additional API calls
     Set(AppState, Patch(AppState, {UserPermissions: UserPermissions}));
     ```

  3. Add error handling wrapper around critical path (error-handling logic moved to Task 3):
     - Will be enhanced in next task with try/catch or IfError pattern

  4. Add comment explaining:
     - Why sequential: permissions depend on roles, roles depend on profile
     - Why not parallel: data dependencies require sequential execution
     - Cache TTL: 5 minutes (AppConfig.CacheExpiryMinutes)
     - Session scope: cache cleared on next app startup
  </action>
  <verify>
  - "0. CRITICAL PATH" section exists in App.OnStart before section "4. DATA CACHE"
  - CachedProfileCache collection initialized via ClearCollect
  - CacheTimestamp set to Now()
  - Office365Users.MyProfileV2() called in CachedProfileCache load
  - UserRoles Named Formula referenced to trigger role evaluation
  - UserPermissions Named Formula referenced to complete authorization
  - No Concurrent() used in critical path (sequential execution)
  - Code compiles without syntax errors
  </verify>
  <done>
  - Cache collections initialized (CachedProfileCache, CachedRolesCache)
  - Critical path loads sequentially: user → roles → permissions
  - Timestamp captured for TTL comparison
  - Dependencies documented in comments
  - App.OnStart flow: cache init → critical path → background data
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error handling to critical path with graceful degradation</name>
  <files>src/App-OnStart-Minimal.fx</files>
  <action>
  Wrap the critical path code from Task 2 with error handling. Implement retry logic and fallback values:

  1. Modify the Office365Users.MyProfileV2() call with IfError pattern:
     ```
     Set(CacheTimestamp, Now());
     Set(AppState, Patch(AppState, {IsInitializing: true}));  // Lock app

     ClearCollect(
       CachedProfileCache,
       IfError(
         {
           DisplayName: Office365Users.MyProfileV2().DisplayName,
           Email: Office365Users.MyProfileV2().UserPrincipalName,
           Department: Office365Users.MyProfileV2().Department,
           JobTitle: Office365Users.MyProfileV2().JobTitle,
           MobilePhone: Office365Users.MyProfileV2().MobilePhone
         },
         // ERROR HANDLER: Critical data failed
         {
           DisplayName: "Unbekannt",
           Email: "unknown@company.com",
           Department: "Unbekannt",
           JobTitle: "Unbekannt",
           MobilePhone: ""
         },
         // Optional: Log error for diagnostics (comment notes for Phase 4+)
         // Could add diagnostics here: Set(AppState, Patch(AppState, {ErrorDetails: Error()}))
       )
     );
     ```

  2. Add blocking error dialog for critical path failure:
     - If Office365Users.MyProfileV2() fails, show user-friendly error message in German
     - Keep app locked (IsInitializing: true) until user acknowledges
     - Message: "Profildaten konnten nicht geladen werden. Bitte überprüfen Sie Ihre Verbindung und aktualisieren Sie die App."
     - Implementation: Show error via Notify() or set ErrorMessage in AppState

  3. Implement fallback for department lookup:
     - If Department is blank or call fails, set to "Unbekannt"
     - Consistent fallback across all profile fields

  4. Add comments explaining:
     - IfError() pattern for graceful degradation
     - Fallback values ensure app can still function
     - Error blocking prevents corrupted state propagation
     - User-friendly error messages in German (no error codes)
  </action>
  <verify>
  - IfError() wraps Office365Users.MyProfileV2() call
  - Fallback object has all required fields (DisplayName, Email, Department, JobTitle, MobilePhone)
  - Fallback values are "Unbekannt" or empty string (appropriate for field)
  - Error message is in German and user-friendly
  - App.OnStart compiles without syntax errors
  - AppState.IsInitializing stays true until critical path completes
  </verify>
  <done>
  - Error handling pattern implemented with IfError()
  - Fallback values documented and consistent ("Unbekannt")
  - User-friendly error messages in German
  - App remains locked during errors (IsInitializing: true)
  - Graceful degradation: app can proceed even if Office365 fails
  </done>
</task>

<task type="auto">
  <name>Task 4: Update UserRoles and UserPermissions Named Formulas to use cached profile</name>
  <files>src/App-Formulas-Template.fx</files>
  <action>
  Modify the UserRoles and UserPermissions Named Formulas to leverage the cached profile instead of calling Office365 APIs repeatedly:

  1. Update UserRoles Named Formula:
     - Current version likely calls Office365Groups.CheckMembershipAsync() for each role
     - New version should cache results in CachedRolesCache collection (initialized in App.OnStart)
     - Pattern: If(IsBlank(CachedRolesCache), {/* first call - populate cache */}, {/* subsequent calls use cache */})
     - Example:
       ```
       UserRoles =
         If(
           IsBlank(CachedRolesCache),
           {
             IsAdmin: Office365Groups.CheckMembershipAsync(AdminGroupId).value,
             IsManager: Office365Groups.CheckMembershipAsync(ManagerGroupId).value,
             IsHR: Office365Groups.CheckMembershipAsync(HRGroupId).value,
             ...
           },
           CachedRolesCache
         );
       ```

  2. Add documentation to UserRoles:
     - Notes that this is called once in App.OnStart to populate cache
     - Subsequent app operations read CachedRolesCache, not the Named Formula
     - TTL: 5 minutes per CacheTimestamp

  3. Verify UserPermissions Named Formula:
     - Should ONLY read from UserRoles (or CachedRolesCache)
     - Must NOT call any Office365 APIs
     - Example: HasRole(roleName) should be: Find(roleName, UserRoles) <> Blank

  4. Add comments explaining cache dependency:
     - "UserRoles calls Office365Groups only if cache is empty (first call in session)"
     - "Subsequent app operations use CachedRolesCache - no additional API calls"
     - "UserPermissions derives from cached roles - no API calls"
  </action>
  <verify>
  - UserRoles Named Formula references CachedRolesCache collection
  - UserRoles formula has IsBlank() check to determine cache hit/miss
  - UserRoles formula calls Office365Groups.CheckMembershipAsync() only on cache miss
  - UserPermissions formula ONLY reads from UserRoles (or cache), no API calls
  - All Office365Groups calls removed from UserPermissions
  - Code compiles without syntax errors
  </verify>
  <done>
  - UserRoles leverages CachedRolesCache for subsequent reads
  - UserPermissions has no API calls (derives from cached roles)
  - Cache pattern consistent across UserProfile, UserRoles, UserPermissions
  - Critical path reduced from multiple API calls to one-per-session
  - Office365Users.MyProfileV2() called once per session
  - Office365Groups.CheckMembershipAsync() called once per role check per session (not per formula evaluation)
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **App.OnStart Execution Order:**
   - AppState initialized (line ~103)
   - ActiveFilters initialized (line ~166)
   - UIState initialized (line ~225)
   - NEW: "0. CRITICAL PATH" section (before line 248)
     - CachedProfileCache initialized
     - CacheTimestamp set
     - Office365Users.MyProfileV2() called once
     - UserRoles evaluated (caches results)
     - UserPermissions evaluated (no API calls)
   - "4. DATA CACHE" continues (parallel lookup data via Concurrent)
   - "5. USER-SCOPED DATA" continues (recent items, tasks)
   - "6. FINALIZE" sets IsInitializing: false

2. **Cache Collections Exist:**
   - CachedProfileCache (holds user profile object)
   - CachedRolesCache (holds roles object)
   - Both initialized before use

3. **Error Handling Works:**
   - IfError() wraps Office365Users call
   - Fallback values populated if API fails
   - User sees German error message, not technical codes
   - App stays locked (IsInitializing: true) during critical error

4. **API Call Counting:**
   - Office365Users.MyProfileV2() called exactly 1 time during App.OnStart (critical path)
   - Office365Groups.CheckMembershipAsync() called once per role during critical path
   - Subsequent app operations read from cache, not API
   - Use Power Apps Monitor to trace API calls

5. **No Regression:**
   - App.OnStart completes (no infinite loops)
   - UserProfile, UserRoles, UserPermissions return expected values
   - Control bindings that use these Named Formulas still work
</verification>

<success_criteria>
- [ ] CachedProfileCache collection created and populated with user profile from Office365Users.MyProfileV2()
- [ ] CachedRolesCache collection created and populated with user roles from Office365Groups checks
- [ ] UserProfile Named Formula reads from cache if available, calls API only on cache miss
- [ ] UserRoles Named Formula reads from cache if available, calls Office365Groups only on cache miss
- [ ] UserPermissions Named Formula derives from cached roles with NO API calls
- [ ] Critical path loads sequentially: user profile → roles → permissions (dependencies respected)
- [ ] Error handling with IfError() provides graceful degradation (fallback to "Unbekannt")
- [ ] User-friendly German error messages displayed (no technical error codes)
- [ ] App.OnStart completes without errors
- [ ] IsInitializing flag properly managed (true during load, false at completion)
- [ ] Power Apps Monitor shows Office365 API calls reduced (1 per session, not per formula evaluation)
</success_criteria>

<output>
After completion, create `.planning/phases/02-performance-foundation/02-01-SUMMARY.md` with:
- What caching mechanism was chosen (collections-based cache with TTL)
- Cache initialization and invalidation logic
- Critical path dependency order
- Error handling patterns used
- Office365 API call reduction metrics (before/after comparison)
- Updated CLAUDE.md reference if caching patterns documented
</output>
